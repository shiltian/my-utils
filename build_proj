#!/usr/bin/env python3

import argparse
import copy
import os
import subprocess
import pathlib
import logging
import sys

# Configure logging (console only)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()],
)

logger = logging.getLogger(os.path.basename(__file__))


def run_cmd(base_cmd: list, proj: str, build_type: str, build_root: str):
    """Run a build command for a specific project and build type."""
    cmd = copy.deepcopy(base_cmd)
    cwd = os.path.join(build_root, proj, build_type)

    logger.info(f"Building project '{proj}' with build type '{build_type}'")
    logger.info(f"Working directory: {cwd}")
    logger.debug(f"Command: {' '.join(cmd)}")

    # Check if the working directory exists
    if not os.path.exists(cwd):
        logger.error(f"Build directory does not exist: {cwd}")
        raise FileNotFoundError(f"Build directory not found: {cwd}")

    try:
        logger.info(f"Executing: cd {cwd}; {' '.join(cmd)}")
        subprocess.run(cmd, cwd=cwd, check=True)
        logger.info(f"Successfully built {proj}:{build_type}")

    except subprocess.CalledProcessError as e:
        logger.error(f"Build failed for {proj}:{build_type}")
        logger.error(f"Return code: {e.returncode}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error while building {proj}:{build_type}: {e}")
        raise


def main():
    logger.info("Starting build_proj script")

    parser = argparse.ArgumentParser(
        prog="build_proj", description="Build a Ninja project"
    )

    parser.add_argument(
        "-b",
        "--build-root",
        type=pathlib.Path,
        default=None,
        help="Root directory for builds",
    )
    parser.add_argument(
        "-j", "--jobs", type=int, default=None, help="Number of parallel jobs"
    )
    parser.add_argument(
        "projs",
        nargs="*",
        type=str,
        default=["llvm@release,debug"],
        help="Projects to build in format 'project@build_type1,build_type2'",
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose logging"
    )

    args = parser.parse_args()

    # Set logging level based on verbose flag
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose logging enabled")

    logger.info(f"Parsed arguments: jobs={args.jobs}, projects={args.projs}")

    # Determine build root
    try:
        build_root = args.build_root if args.build_root else os.environ["BUILD_ROOT"]
        logger.info(f"Using build root: {build_root}")
    except KeyError:
        logger.error(
            "BUILD_ROOT environment variable not set and --build-root not provided"
        )
        sys.exit(1)

    # Validate build root exists
    if not os.path.exists(build_root):
        logger.error(f"Build root directory does not exist: {build_root}")
        sys.exit(1)

    logger.info(f"Build configuration - Jobs: {args.jobs}, Projects: {args.projs}")

    # Construct the list of projects to be built and their build types
    projs = {}
    logger.debug("Parsing project specifications...")

    for p in args.projs:
        logger.debug(f"Processing project spec: {p}")
        p_parts = p.split("@")
        name = p_parts[0].lower()

        if len(p_parts) > 1:
            build_types = p_parts[1].split(",")
        else:
            build_types = ["release"]
            logger.debug(
                f"No build types specified for {name}, defaulting to 'release'"
            )

        if name not in projs:
            projs[name] = []

        for t in build_types:
            build_type = t.lower()
            projs[name].append(build_type)
            logger.debug(f"Added build type '{build_type}' for project '{name}'")

    logger.info(f"Final project configuration: {projs}")

    # Construct ninja command
    cmd = ["ninja", "-k", "0"]
    if args.jobs:
        cmd += ["-j", str(args.jobs)]
        logger.info(f"Using {args.jobs} parallel jobs")
    else:
        logger.info("Using default number of parallel jobs")

    logger.debug(f"Base ninja command: {' '.join(cmd)}")

    # Execute builds
    total_builds = sum(len(build_types) for build_types in projs.values())
    logger.info(f"Starting {total_builds} build(s)")

    build_count = 0
    failed_builds = []

    for p in projs:
        for t in projs[p]:
            build_count += 1
            logger.info(f"Build {build_count}/{total_builds}: {p}:{t}")

            try:
                run_cmd(cmd, p, t, build_root)
                logger.info(
                    f"✓ Successfully completed build {build_count}/{total_builds}: {p}:{t}"
                )
            except Exception as e:
                failed_builds.append(f"{p}:{t}")
                logger.error(
                    f"✗ Failed build {build_count}/{total_builds}: {p}:{t} - {e}"
                )
                # Continue with other builds instead of failing immediately

    # Summary
    successful_builds = total_builds - len(failed_builds)
    logger.info(f"Build summary: {successful_builds}/{total_builds} successful")

    if failed_builds:
        logger.warning(f"Failed builds: {', '.join(failed_builds)}")
        logger.info("Build completed with failures")
        sys.exit(1)
    else:
        logger.info("All builds completed successfully!")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Build interrupted by user")
        sys.exit(130)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)
