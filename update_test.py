#!/usr/bin/env python3
"""
Update LLVM test files that are generated by scripts.

This tool processes a list of LLVM test files and automatically updates them
using the appropriate update script (e.g., update_llc_test_checks.py).
"""

import argparse
import logging
import os
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

PROG_NAME = "update-test"

# Mapping of test updater scripts to their test types
TEST_UPDATERS = {
    "update_llc_test_checks.py": "llc",
    "update_mir_test_checks.py": "mir",
    "update_test_checks.py": "opt",
    "update_mc_test_checks.py": "llvm-mc",
}

# Mapping of lit test suite prefixes to their test directories
# relative to LLVM source root
TEST_SUITE_DIRS = {
    "LLVM": "llvm/test",
    "Clang": "clang/test",
    "clang": "clang/test",  # Some lit configs use lowercase
    "lld": "lld/test",
    "lldb": "lldb/test",
    "mlir": "mlir/test",
    "flang": "flang/test",
    "clang-tools-extra": "clang-tools-extra/test",
    "compiler-rt": "compiler-rt/test",
    "libcxx": "libcxx/test",
    "libcxxabi": "libcxxabi/test",
    "libunwind": "libunwind/test",
    "openmp": "openmp/test",
    "polly": "polly/test",
}

# Default test directory when no prefix is specified
DEFAULT_TEST_DIR = "llvm/test"

logger = logging.getLogger(PROG_NAME)


class ProgressBar:
    """A simple progress bar using only standard library."""

    def __init__(self, total: int, desc: str = "Progress", width: int = 40):
        """
        Initialize the progress bar.

        Args:
            total: Total number of items to process
            desc: Description to show before the progress bar
            width: Width of the progress bar in characters
        """
        self.total = total
        self.current = 0
        self.desc = desc
        self.width = width
        self.start_time = time.time()
        self.success = 0
        self.failure = 0
        self.enabled = sys.stderr.isatty()

    def update(self, success: bool = True) -> None:
        """
        Update the progress bar.

        Args:
            success: Whether the current item succeeded
        """
        self.current += 1
        if success:
            self.success += 1
        else:
            self.failure += 1

        if self.enabled:
            self._render()

    def _render(self) -> None:
        """Render the progress bar to stderr."""
        if self.total == 0:
            return

        # Calculate progress
        progress = self.current / self.total
        filled = int(self.width * progress)
        bar = "=" * filled + "-" * (self.width - filled)

        # Calculate time
        elapsed = time.time() - self.start_time
        if self.current > 0:
            eta = elapsed / self.current * (self.total - self.current)
            eta_str = self._format_time(eta)
        else:
            eta_str = "??"

        elapsed_str = self._format_time(elapsed)

        # Build the progress line
        percent = int(progress * 100)
        status = f"✓ {self.success} ✗ {self.failure}"
        line = (
            f"\r{self.desc}: [{bar}] {self.current}/{self.total} "
            f"({percent}%) {elapsed_str}<{eta_str} {status}"
        )

        # Write to stderr
        sys.stderr.write(line)
        sys.stderr.flush()

        # Add newline on completion
        if self.current == self.total:
            sys.stderr.write("\n")
            sys.stderr.flush()

    def _format_time(self, seconds: float) -> str:
        """Format seconds into MM:SS."""
        mins = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{mins:02d}:{secs:02d}"

    def close(self) -> None:
        """Close the progress bar, ensuring a newline is written."""
        if self.enabled and self.current < self.total:
            sys.stderr.write("\n")
            sys.stderr.flush()


@dataclass
class Config:
    """Configuration for the test updater."""

    llvm_src_root: Path
    test_file: Path
    verbose: bool
    show_progress: bool


class TestUpdateError(Exception):
    """Exception raised when test update fails."""

    pass


def setup_logging(verbose: bool) -> None:
    """Configure logging based on verbosity level."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(levelname)s: %(message)s",
        stream=sys.stderr,
    )


def run_update(
    llvm_root: Path, updater_script: str, test_path: Path, verbose: bool
) -> None:
    """
    Run the test updater script on a test file.

    Args:
        llvm_root: Path to LLVM source root directory
        updater_script: Name of the updater script to run
        test_path: Path to the test file to update
        verbose: Whether to show updater output

    Raises:
        TestUpdateError: If the updater script fails
    """
    updater_path = llvm_root / "llvm" / "utils" / updater_script

    if not updater_path.exists():
        raise TestUpdateError(f"Updater script not found: {updater_path}")

    stdout = None if verbose else subprocess.DEVNULL
    stderr = None if verbose else subprocess.DEVNULL

    try:
        subprocess.run(
            [str(updater_path), str(test_path)],
            stdout=stdout,
            stderr=stderr,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        raise TestUpdateError(
            f"Failed to update test {test_path} with {updater_script}: {e}"
        ) from e


def detect_updater(test_path: Path) -> Optional[tuple[str, str]]:
    """
    Detect which updater script should be used for a test file.

    Args:
        test_path: Path to the test file

    Returns:
        A tuple of (updater_script, test_kind) if found, None otherwise
    """
    try:
        with test_path.open("r", encoding="utf-8") as f:
            first_line = f.readline()
    except (IOError, UnicodeDecodeError) as e:
        logger.error(f"Failed to read test file {test_path}: {e}")
        return None

    if "autogenerated" not in first_line.lower():
        logger.warning(f"Test {test_path} was not auto-generated. Skipped.")
        return None

    for updater_script, test_kind in TEST_UPDATERS.items():
        if updater_script in first_line:
            return updater_script, test_kind

    logger.error(f"Unknown test updater in {test_path}: {first_line.strip()}")
    return None


def resolve_test_path(
    test_path_str: str, llvm_root: Path, suite_prefix: Optional[str] = None
) -> Path:
    """
    Resolve a test path string to an absolute Path.

    Args:
        test_path_str: Test path as string (relative or absolute)
        llvm_root: LLVM source root directory
        suite_prefix: Optional lit test suite prefix (e.g., "LLVM", "Clang")

    Returns:
        Resolved absolute Path
    """
    test_path = Path(test_path_str)
    if not test_path.is_absolute():
        # Determine the test directory based on the suite prefix
        if suite_prefix and suite_prefix in TEST_SUITE_DIRS:
            test_dir = TEST_SUITE_DIRS[suite_prefix]
            logger.debug(
                f"Using test directory '{test_dir}' for suite '{suite_prefix}'"
            )
        else:
            test_dir = DEFAULT_TEST_DIR
            if suite_prefix:
                logger.warning(
                    f"Unknown test suite prefix '{suite_prefix}', "
                    f"using default directory '{test_dir}'"
                )

        test_path = llvm_root / test_dir / test_path_str

    return test_path.resolve()


def process_test_file(test_path: Path, config: Config) -> bool:
    """
    Process a single test file and update it if applicable.

    Args:
        test_path: Path to the test file
        config: Configuration object

    Returns:
        True if processing succeeded, False otherwise
    """
    logger.debug(f"Processing {test_path}...")

    if not test_path.exists():
        logger.error(f"Test file does not exist: {test_path}")
        return False

    result = detect_updater(test_path)
    if result is None:
        return False

    updater_script, test_kind = result
    logger.debug(f"Test {test_path} is a {test_kind} test. Updating...")

    try:
        run_update(config.llvm_src_root, updater_script, test_path, config.verbose)
        logger.debug(f"Test {test_path} updated successfully.")
        return True
    except TestUpdateError as e:
        logger.error(str(e))
        return False


def parse_test_path(line: str) -> Optional[tuple[str, Optional[str]]]:
    """
    Parse a test path from a line, handling various formats.

    Supports:
    - Plain test paths: CodeGen/AMDGPU/test.ll
    - Lit test format: LLVM :: CodeGen/AMDGPU/test.ll
    - With leading whitespace

    Args:
        line: Line from test list file

    Returns:
        Tuple of (test_path, suite_prefix) or None if line is empty.
        suite_prefix is None if no lit prefix was found.
    """
    line = line.strip()
    if not line:
        return None

    suite_prefix = None

    # Check for lit test format (e.g., "LLVM :: CodeGen/AMDGPU/test.ll")
    # Common prefixes: LLVM ::, Clang ::, Clang-Unit ::, lld ::, etc.
    if "::" in line:
        # Split on :: and take the part after it
        parts = line.split("::", 1)
        if len(parts) == 2:
            suite_prefix = parts[0].strip()
            line = parts[1].strip()

    return (line, suite_prefix)


def load_test_list(test_file: Path) -> list[tuple[str, Optional[str]]]:
    """
    Load and parse the test list file.

    Supports multiple formats:
    - Plain test paths (one per line)
    - Lit test output format (e.g., "LLVM :: CodeGen/test.ll")

    Args:
        test_file: Path to file containing list of tests

    Returns:
        List of tuples (test_path, suite_prefix) for non-empty lines.
        suite_prefix is None for plain paths without a lit prefix.

    Raises:
        TestUpdateError: If the file cannot be read
    """
    try:
        with test_file.open("r", encoding="utf-8") as f:
            lines = f.readlines()
    except IOError as e:
        raise TestUpdateError(f"Failed to read test list file {test_file}: {e}") from e

    test_paths = []
    for line in lines:
        result = parse_test_path(line)
        if result:
            test_paths.append(result)

    return test_paths


def main() -> int:
    """
    Main entry point for the test updater tool.

    Returns:
        Exit code (0 for success, 1 for failure)
    """
    parser = argparse.ArgumentParser(
        prog=PROG_NAME,
        description="Update LLVM test files that are generated by scripts.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Supported test updaters:
  - update_llc_test_checks.py (llc tests)
  - update_mir_test_checks.py (mir tests)
  - update_test_checks.py (opt tests)
  - update_mc_test_checks.py (llvm-mc tests)

Input file formats:
  - Plain test paths: CodeGen/AMDGPU/test.ll (assumed to be under llvm/test/)
  - Lit test output: LLVM :: CodeGen/AMDGPU/test.ll

Supported test suite prefixes:
  - LLVM :: → llvm/test/
  - Clang :: → clang/test/
  - lld :: → lld/test/
  - mlir :: → mlir/test/
  - flang :: → flang/test/
  (and other LLVM subprojects)

The tool automatically maps lit test prefixes to their respective test directories.

Progress bar:
  A progress bar is shown by default when running in an interactive terminal.
  Use --no-progress to disable it (useful in CI or when redirecting output).
        """,
    )

    parser.add_argument(
        "-l",
        "--llvm-src-root",
        required=True,
        type=Path,
        help="LLVM source code root directory",
    )
    parser.add_argument(
        "-f",
        "--test-file",
        required=True,
        type=Path,
        help="File containing list of tests to be updated (one per line). "
        "Supports plain paths or lit test output format (e.g., 'LLVM :: CodeGen/test.ll')",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output",
    )
    parser.add_argument(
        "--no-progress",
        action="store_true",
        help="Disable progress bar (useful for CI or when redirecting output)",
    )

    args = parser.parse_args()
    setup_logging(args.verbose)

    # Determine if we should show progress bar
    show_progress = not args.no_progress and sys.stderr.isatty()

    try:
        config = Config(
            llvm_src_root=args.llvm_src_root.resolve(),
            test_file=args.test_file.resolve(),
            verbose=args.verbose,
            show_progress=show_progress,
        )
    except (ValueError, OSError) as e:
        logger.error(f"Invalid path provided: {e}")
        return 1

    if not config.llvm_src_root.exists():
        logger.error(f"LLVM source root does not exist: {config.llvm_src_root}")
        return 1

    if not config.test_file.exists():
        logger.error(f"Test list file does not exist: {config.test_file}")
        return 1

    try:
        test_list = load_test_list(config.test_file)
    except TestUpdateError as e:
        logger.error(str(e))
        return 1

    if not test_list:
        logger.warning("Test list file is empty.")
        return 0

    logger.info(f"Processing {len(test_list)} test(s)...")

    success_count = 0
    failure_count = 0

    # Create progress bar if enabled
    progress_bar = None
    if config.show_progress:
        progress_bar = ProgressBar(len(test_list), desc="Updating tests", width=40)

    for test_path_str, suite_prefix in test_list:
        test_path = resolve_test_path(test_path_str, config.llvm_src_root, suite_prefix)
        success = process_test_file(test_path, config)

        if success:
            success_count += 1
        else:
            failure_count += 1

        if progress_bar:
            progress_bar.update(success=success)

    if progress_bar:
        progress_bar.close()

    logger.info(
        f"Completed: {success_count} succeeded, {failure_count} failed/skipped."
    )

    return 0 if failure_count == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
